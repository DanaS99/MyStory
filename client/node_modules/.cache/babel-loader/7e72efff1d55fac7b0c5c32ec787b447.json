{"ast":null,"code":"/*!\nFullCalendar v5.5.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\nimport moment from 'moment';\nimport { createPlugin, CalendarApi } from '@fullcalendar/common';\n\nfunction toMoment(date, calendar) {\n  if (!(calendar instanceof CalendarApi)) {\n    throw new Error('must supply a CalendarApi instance');\n  }\n\n  var dateEnv = calendar.getCurrentData().dateEnv;\n  return convertToMoment(date, dateEnv.timeZone, null, dateEnv.locale.codes[0]);\n}\n\nfunction toMomentDuration(fcDuration) {\n  return moment.duration(fcDuration); // moment accepts all the props that fc.Duration already has!\n}\n\nfunction formatWithCmdStr(cmdStr, arg) {\n  var cmd = parseCmdStr(cmdStr);\n\n  if (arg.end) {\n    var startMom = convertToMoment(arg.start.array, arg.timeZone, arg.start.timeZoneOffset, arg.localeCodes[0]);\n    var endMom = convertToMoment(arg.end.array, arg.timeZone, arg.end.timeZoneOffset, arg.localeCodes[0]);\n    return formatRange(cmd, createMomentFormatFunc(startMom), createMomentFormatFunc(endMom), arg.defaultSeparator);\n  }\n\n  return convertToMoment(arg.date.array, arg.timeZone, arg.date.timeZoneOffset, arg.localeCodes[0]).format(cmd.whole); // TODO: test for this\n}\n\nvar main = createPlugin({\n  cmdFormatter: formatWithCmdStr\n});\n\nfunction createMomentFormatFunc(mom) {\n  return function (cmdStr) {\n    return cmdStr ? mom.format(cmdStr) : '' // because calling with blank string results in ISO8601 :(\n    ;\n  };\n}\n\nfunction convertToMoment(input, timeZone, timeZoneOffset, locale) {\n  var mom;\n\n  if (timeZone === 'local') {\n    mom = moment(input);\n  } else if (timeZone === 'UTC') {\n    mom = moment.utc(input);\n  } else if (moment.tz) {\n    mom = moment.tz(input, timeZone);\n  } else {\n    mom = moment.utc(input);\n\n    if (timeZoneOffset != null) {\n      mom.utcOffset(timeZoneOffset);\n    }\n  }\n\n  mom.locale(locale);\n  return mom;\n}\n\nfunction parseCmdStr(cmdStr) {\n  var parts = cmdStr.match(/^(.*?)\\{(.*)\\}(.*)$/); // TODO: lookbehinds for escape characters\n\n  if (parts) {\n    var middle = parseCmdStr(parts[2]);\n    return {\n      head: parts[1],\n      middle: middle,\n      tail: parts[3],\n      whole: parts[1] + middle.whole + parts[3]\n    };\n  }\n\n  return {\n    head: null,\n    middle: null,\n    tail: null,\n    whole: cmdStr\n  };\n}\n\nfunction formatRange(cmd, formatStart, formatEnd, separator) {\n  if (cmd.middle) {\n    var startHead = formatStart(cmd.head);\n    var startMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);\n    var startTail = formatStart(cmd.tail);\n    var endHead = formatEnd(cmd.head);\n    var endMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);\n    var endTail = formatEnd(cmd.tail);\n\n    if (startHead === endHead && startTail === endTail) {\n      return startHead + (startMiddle === endMiddle ? startMiddle : startMiddle + separator + endMiddle) + startTail;\n    }\n  }\n\n  var startWhole = formatStart(cmd.whole);\n  var endWhole = formatEnd(cmd.whole);\n\n  if (startWhole === endWhole) {\n    return startWhole;\n  }\n\n  return startWhole + separator + endWhole;\n}\n\nexport default main;\nexport { toMoment, toMomentDuration };","map":{"version":3,"sources":["src/main.ts"],"names":[],"mappings":"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","sourcesContent":["import moment from 'moment'\nimport { Duration, VerboseFormattingArg, createPlugin, CalendarApi } from '@fullcalendar/common'\n\nexport function toMoment(date: Date, calendar: CalendarApi): moment.Moment {\n  if (!(calendar instanceof CalendarApi)) {\n    throw new Error('must supply a CalendarApi instance')\n  }\n\n  let { dateEnv } = calendar.getCurrentData()\n\n  return convertToMoment(\n    date,\n    dateEnv.timeZone,\n    null,\n    dateEnv.locale.codes[0],\n  )\n}\n\nexport function toMomentDuration(fcDuration: Duration): moment.Duration {\n  return moment.duration(fcDuration) // moment accepts all the props that fc.Duration already has!\n}\n\nfunction formatWithCmdStr(cmdStr: string, arg: VerboseFormattingArg) {\n  let cmd = parseCmdStr(cmdStr)\n\n  if (arg.end) {\n    let startMom = convertToMoment(\n      arg.start.array,\n      arg.timeZone,\n      arg.start.timeZoneOffset,\n      arg.localeCodes[0],\n    )\n    let endMom = convertToMoment(\n      arg.end.array,\n      arg.timeZone,\n      arg.end.timeZoneOffset,\n      arg.localeCodes[0],\n    )\n    return formatRange(\n      cmd,\n      createMomentFormatFunc(startMom),\n      createMomentFormatFunc(endMom),\n      arg.defaultSeparator,\n    )\n  }\n\n  return convertToMoment(\n    arg.date.array,\n    arg.timeZone,\n    arg.date.timeZoneOffset,\n    arg.localeCodes[0],\n  ).format(cmd.whole) // TODO: test for this\n}\n\nexport default createPlugin({\n  cmdFormatter: formatWithCmdStr,\n})\n\nfunction createMomentFormatFunc(mom: moment.Moment) {\n  return (cmdStr) => (\n    cmdStr ? mom.format(cmdStr) : '' // because calling with blank string results in ISO8601 :(\n  )\n}\n\nfunction convertToMoment(input: any, timeZone: string, timeZoneOffset: number | null, locale: string): moment.Moment {\n  let mom: moment.Moment\n\n  if (timeZone === 'local') {\n    mom = moment(input)\n  } else if (timeZone === 'UTC') {\n    mom = moment.utc(input)\n  } else if ((moment as any).tz) {\n    mom = (moment as any).tz(input, timeZone)\n  } else {\n    mom = moment.utc(input)\n\n    if (timeZoneOffset != null) {\n      mom.utcOffset(timeZoneOffset)\n    }\n  }\n\n  mom.locale(locale)\n\n  return mom\n}\n\n/* Range Formatting (duplicate code as other date plugins)\n----------------------------------------------------------------------------------------------------*/\n\ninterface CmdParts {\n  head: string | null\n  middle: CmdParts | null\n  tail: string | null\n  whole: string\n}\n\nfunction parseCmdStr(cmdStr: string): CmdParts {\n  let parts = cmdStr.match(/^(.*?)\\{(.*)\\}(.*)$/) // TODO: lookbehinds for escape characters\n\n  if (parts) {\n    let middle = parseCmdStr(parts[2])\n\n    return {\n      head: parts[1],\n      middle,\n      tail: parts[3],\n      whole: parts[1] + middle.whole + parts[3],\n    }\n  }\n\n  return {\n    head: null,\n    middle: null,\n    tail: null,\n    whole: cmdStr,\n  }\n}\n\nfunction formatRange(\n  cmd: CmdParts,\n  formatStart: (cmdStr: string) => string,\n  formatEnd: (cmdStr: string) => string,\n  separator: string,\n): string {\n  if (cmd.middle) {\n    let startHead = formatStart(cmd.head)\n    let startMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator)\n    let startTail = formatStart(cmd.tail)\n\n    let endHead = formatEnd(cmd.head)\n    let endMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator)\n    let endTail = formatEnd(cmd.tail)\n\n    if (startHead === endHead && startTail === endTail) {\n      return startHead +\n        (startMiddle === endMiddle ? startMiddle : startMiddle + separator + endMiddle) +\n        startTail\n    }\n  }\n\n  let startWhole = formatStart(cmd.whole)\n  let endWhole = formatEnd(cmd.whole)\n\n  if (startWhole === endWhole) {\n    return startWhole\n  }\n\n  return startWhole + separator + endWhole\n}\n"]},"metadata":{},"sourceType":"module"}